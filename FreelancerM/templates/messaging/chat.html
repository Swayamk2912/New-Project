{% extends 'base.html' %}

{% block content %}
<div class="container mt-5 chat-container">
    <div class="card">
        <div class="card-header chat-header d-flex justify-content-between align-items-center">
            <div>
                Chat with 
                {% for participant in conversation.participants.all %}
                    {% if participant != request.user %}
                        {{ participant.username }}
                    {% endif %}
                {% endfor %}
                {% if job %}
                    - {{ job.title }}
                {% endif %}
            </div>
            <div class="chat-icons mr-2">
                <button class="btn btn-success btn-sm" id="start-video-call">Video Call</button>
                <button class="btn btn-info btn-sm ml-2" id="start-audio-call">Call</button>
                <button id="delete-conversation-btn" class="btn btn-danger btn-sm ml-3">Delete Conversation</button>
            </div>
        </div>
        <div class="card-body chat-messages" id="chat-log">
            {% for message in messages %}
                {% if not message.is_deleted %}
                    <div class="message-bubble {% if message.sender == request.user %}sent{% else %}received{% endif %}" data-message-id="{{ message.id }}">
                        <strong>{{ message.sender.username }}</strong>: {{ message.content }}
                        <br>
                        <small class="text-muted">{{ message.timestamp|date:"N j, Y, P" }}</small>
                        {% if message.sender == request.user %}
                            <button class="btn btn-sm btn-outline-danger delete-message-btn" data-message-id="{{ message.id }}">Delete Message</button>
                        {% endif %}
                    </div>
                {% else %}
                    <div class="message-bubble deleted-message {% if message.sender == request.user %}sent{% else %}received{% endif %}">
                        <em>This message was deleted.</em>
                        <br>
                        <small class="text-muted">{{ message.timestamp|date:"N j, Y, P" }}</small>
                    </div>
                {% endif %}
            {% endfor %}
        </div>
        <div class="card-footer chat-input-area">
            <form id="chat-form">
                <div class="input-group">
                    <input type="text" id="chat-message-input" class="form-control" placeholder="Type your message...">
                    <div class="input-group-append">
                        <button type="submit" id="chat-message-submit" class="btn btn-primary">Send</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Incoming Call Modal -->
<div class="modal fade" id="incomingCallModal" tabindex="-1" aria-labelledby="incomingCallModalLabel">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="incomingCallModalLabel">Incoming Call</h5>
            </div>
            <div class="modal-body">
                <p id="incoming-call-text">You have an incoming call.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-success" id="accept-call"><i class="fas fa-phone"></i> Accept</button>
                <button type="button" class="btn btn-danger" id="reject-call"><i class="fas fa-phone-slash"></i> Reject</button>
            </div>
        </div>
    </div>
</div>

<!-- Call Modal -->
<div class="modal fade" id="callModal" tabindex="-1" aria-labelledby="callModalLabel">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="callModalLabel">Call</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body d-flex">
                <video id="local-video" autoplay muted playsinline style="width: 25%; max-height:60vh; margin-right:1rem; background:#000;"></video>
                <video id="remote-video" autoplay playsinline style="flex:1; max-height:60vh; background:#000;"></video>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" id="end-call">End Call</button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    console.log("chat.html script loaded.");

    // ---- Template variables (safe) ----
    const conversationId = {{ conversation.id }};
    const currentUser = "{{ request.user.username|escapejs }}";

    // ---- WebSocket setup ----
    const proto = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
    const wsUrl = `${proto}//${window.location.host}/ws/chat/${conversationId}/`;
    console.log("WebSocket URL:", wsUrl);

    let chatSocket = null;
    let signalQueue = []; // queue messages until socket is open

    function createWebSocket() {
        chatSocket = new WebSocket(wsUrl);

        chatSocket.onopen = () => {
            console.log("WebSocket opened.");
            // flush queue
            while (signalQueue.length) {
                const queued = signalQueue.shift();
                try {
                    chatSocket.send(JSON.stringify(queued));
                } catch (err) {
                    console.error("Error sending queued message:", err, queued);
                }
            }
        };

        chatSocket.onmessage = (e) => {
            try {
                const data = JSON.parse(e.data);
                console.log("WS message received:", data);
                handleSocketMessage(data);
            } catch (err) {
                console.error("Error parsing WS message:", err, e.data);
            }
        };

        chatSocket.onerror = (err) => {
            console.error("WebSocket error:", err);
        };

        chatSocket.onclose = (ev) => {
            console.warn("WebSocket closed:", ev);
            // Optionally try to reconnect after a short delay
            // setTimeout(createWebSocket, 2000);
        };
    }

    createWebSocket();

    function safeSend(obj) {
        obj.sender = currentUser;
        // ensure call_id present if we have one (some messages may set explicit)
        try {
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify(obj));
            } else {
                console.log("WS not open yet, queueing:", obj);
                signalQueue.push(obj);
            }
        } catch (err) {
            console.error("safeSend error:", err, obj);
        }
    }

    // ---- RTC + call state ----
    let localStream = null;
    let peerConnection = null;
    let callId = null;
    let pendingOffer = null;
    let pendingIceCandidates = []; // ICE candidates received before pc is ready
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const callModal = new bootstrap.Modal(document.getElementById('callModal'));
    const incomingCallModal = new bootstrap.Modal(document.getElementById('incomingCallModal'));
    const incomingCallText = document.getElementById('incoming-call-text');

    function handleSocketMessage(data) {
        const chatLog = document.querySelector('#chat-log');
        if (!data.type) return;

        if (data.type === 'chat_message') {
            const messageHtml = `
                <div class="message-bubble ${data.sender === currentUser ? 'sent' : 'received'}" data-message-id="${data.message_id}">
                    <strong>${data.sender}</strong>: ${data.message}
                    <br><small class="text-muted">${new Date(data.timestamp).toLocaleString()}</small>
                    ${data.sender === currentUser ? `<button class="btn btn-sm btn-outline-danger delete-message-btn" data-message-id="${data.message_id}">Delete</button>` : ''}
                </div>
            `;
            chatLog.innerHTML += messageHtml;
            chatLog.scrollTop = chatLog.scrollHeight;
            return;
        }

        if (data.type === 'message_deleted') {
            const messageBubble = document.querySelector(`.message-bubble[data-message-id="${data.message_id}"]`);
            if (messageBubble) {
                messageBubble.innerHTML = `<em>This message was deleted.</em><br><small class="text-muted">${new Date(data.timestamp).toLocaleString()}</small>`;
                messageBubble.classList.add('deleted-message');
            }
            return;
        }

        if (data.type === 'conversation_deleted') {
            alert('This conversation has been deleted.');
            window.location.href = '{% url "messaging:inbox" %}';
            return;
        }

        // signaling / call messages:
        if (data.type === 'call_initiate') {
            if (data.sender === currentUser) return; // ignore our own initiate
            console.log("Received call_initiate:", data);
            callId = data.call_id || callId;
            incomingCallText.textContent = `Incoming call from ${data.sender}`;
            incomingCallModal.show();
            return;
        }

        if (data.type === 'webrtc_offer') {
            console.log("Received webrtc_offer:", !!data.offer);

            // Glare handling: If we are already in the process of making an offer,
            // ignore incoming offers to prevent race conditions.
            if (peerConnection && peerConnection.signalingState === 'have-local-offer') {
                console.warn("Ignoring incoming offer to prevent glare. Our offer will take precedence.");
                return;
            }

            // store the offer until user accepts (or accept automatically)
            pendingOffer = data.offer;
            callId = data.call_id || callId;
            // if we've already accepted/created pc, process immediately
            if (peerConnection && localStream) {
                applyRemoteOfferAndAnswer();
            } else {
                incomingCallText.textContent = `Incoming call from ${data.sender}`;
                incomingCallModal.show();
            }
            return;
        }

        if (data.type === 'webrtc_answer') {
            console.log("Received webrtc_answer");
            if (peerConnection) {
                peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer))
                    .catch(err => console.error("Error setting remote description (answer):", err));
            } else {
                console.warn("Received answer but peerConnection missing. Ignoring.");
            }
            return;
        }

        if (data.type === 'webrtc_ice_candidate') {
            console.log("Received ICE candidate");
            const candidate = data.candidate;
            if (peerConnection) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                    .catch(err => console.error("Error adding ICE candidate:", err));
            } else {
                // store until pc created
                pendingIceCandidates.push(candidate);
            }
            return;
        }

        if (data.type === 'call_status') {
            console.log("Received call_status:", data.status);
            if (data.status === 'rejected' || data.status === 'ended') {
                cleanupCallUI();
            }
            // Note: 'accepted' status is implicitly handled by the WebRTC answer flow.
            // No specific action is needed here for 'accepted'.
            return;
        }
    }

    function createPeerConnectionAndAttachLocal() {
        if (peerConnection) {
            try { peerConnection.close(); } catch(e) {}
            peerConnection = null;
        }

        peerConnection = new RTCPeerConnection(configuration);
        console.log("Created RTCPeerConnection");

        peerConnection.ontrack = (ev) => {
            console.log("ontrack event received:", ev);
            const remoteVideo = document.getElementById('remote-video');
            if (!remoteVideo) {
                console.error("remote-video element not found!");
                return;
            }

            if (remoteVideo.srcObject !== ev.streams[0]) {
                if (ev.streams && ev.streams[0]) {
                    console.log("Setting remote-video srcObject to ev.streams[0]:", ev.streams[0]);
                    remoteVideo.srcObject = ev.streams[0];
                } else {
                    // fallback: construct stream from tracks
                    console.warn("ev.streams[0] not available, constructing MediaStream from tracks.");
                    const remoteStream = new MediaStream();
                    ev.streams && ev.streams.forEach(s => {
                        console.log("Adding tracks from stream:", s);
                        s.getTracks().forEach(t => remoteStream.addTrack(t));
                    });
                    remoteVideo.srcObject = remoteStream;
                }
                // Attempt to play the video, crucial for some browsers due to autoplay policies
                remoteVideo.play().catch(err => {
                    console.error("Error attempting to play remote video:", err);
                    // User might need to interact with the page for autoplay to work
                });
            }
            console.log("remote-video srcObject set. remoteVideo.readyState:", remoteVideo.readyState);
        };

        peerConnection.onicecandidate = (e) => {
            if (e.candidate) {
                console.log("Local ICE candidate:", e.candidate);
                safeSend({ type: 'webrtc_ice_candidate', candidate: e.candidate });
            }
        };

        // attach local tracks (if available)
        if (localStream) {
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            console.log("Attached local tracks to pc");
        }

        // flush pending ICE candidates received earlier
        if (pendingIceCandidates.length) {
            pendingIceCandidates.forEach(cand => {
                peerConnection.addIceCandidate(new RTCIceCandidate(cand)).catch(err => console.error("Error adding pending ICE candidate:", err));
            });
            pendingIceCandidates = [];
        }

        return peerConnection;
    }

    function applyRemoteOfferAndAnswer() {
        if (!pendingOffer) {
            console.warn("No pending offer to apply.");
            return;
        }
        if (!peerConnection) createPeerConnectionAndAttachLocal();

        console.log("Setting remote description (offer)...");
        peerConnection.setRemoteDescription(new RTCSessionDescription(pendingOffer))
            .then(() => {
                console.log("Remote description set, creating answer...");
                return peerConnection.createAnswer();
            })
            .then(answer => {
                return peerConnection.setLocalDescription(answer).then(() => answer);
            })
            .then(answer => {
                console.log("Sending webrtc_answer");
                safeSend({ type: 'webrtc_answer', answer: peerConnection.localDescription });
                // clear pendingOffer
                pendingOffer = null;
            })
            .catch(err => console.error("Error during applyRemoteOfferAndAnswer:", err));
    }

    function cleanupCallUI() {
        try {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
        } catch (err) {
            console.error("Error cleaning up call:", err);
        }
        callModal.hide();
        incomingCallModal.hide();
        document.getElementById('local-video').srcObject = null;
        document.getElementById('remote-video').srcObject = null;
        callId = null;
        pendingOffer = null;
        pendingIceCandidates = [];
    }

    // ---- UI event handlers for call lifecycle ----
    document.getElementById('start-video-call').addEventListener('click', (e) => {
        e.preventDefault();
        console.log("Video Call button clicked");
        initiateCall(true);
    });

    document.getElementById('start-audio-call').addEventListener('click', (e) => {
        e.preventDefault();
        console.log("Audio Call button clicked");
        initiateCall(false);
    });

    function initiateCall(video) {
        // if already in a call, ignore
        if (peerConnection || callId) {
            console.warn("Already in a call or initiating; ignoring new call request.");
            return;
        }
        callId = Date.now();
        console.log("Initiating call with callId:", callId);

        navigator.mediaDevices.getUserMedia({ video: video, audio: true })
            .then(stream => {
                localStream = stream;
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = stream;
                    localVideo.play().catch(err => console.error("Error playing local video:", err));
                } else {
                    console.error("local-video element not found!");
                }
                createPeerConnectionAndAttachLocal();

                // announce the call
                safeSend({ type: 'call_initiate', call_id: callId });

                peerConnection.createOffer()
                    .then(offer => peerConnection.setLocalDescription(offer).then(() => offer))
                    .then(offer => {
                        console.log("Sending webrtc_offer");
                        safeSend({ type: 'webrtc_offer', offer: peerConnection.localDescription, call_id: callId });
                    })
                    .catch(err => {
                        console.error("Error creating/sending offer:", err);
                        cleanupCallUI();
                    });

                callModal.show();
            })
            .catch(err => {
                console.error("getUserMedia error:", err);
                alert("Cannot access camera/microphone. Please allow permissions.");
            });
    }

    document.getElementById('accept-call').addEventListener('click', () => {
        console.log("Accept call clicked. callId:", callId);
        incomingCallModal.hide();
        // obtain local stream first
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(stream => {
                localStream = stream;
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = stream;
                    localVideo.play().catch(err => console.error("Error playing local video on accept:", err));
                } else {
                    console.error("local-video element not found!");
                }
                createPeerConnectionAndAttachLocal();
                callModal.show();
                // if we already have an offer, apply it (setRemoteDescription & answer)
                if (pendingOffer) {
                    applyRemoteOfferAndAnswer();
                } else {
                    // if no offer yet, at least tell remote we accepted
                    safeSend({ type: 'call_accept', call_id: callId });
                }
            })
            .catch(err => {
                console.error("Error getting media for accept:", err);
                alert("Cannot access camera/microphone. Please allow permissions.");
            });
    });

    document.getElementById('reject-call').addEventListener('click', () => {
        console.log("Reject call clicked.");
        safeSend({ type: 'call_reject', call_id: callId });
        incomingCallModal.hide();
        // keep callId so we can ignore further signaling or allow new calls later
        pendingOffer = null;
        pendingIceCandidates = [];
    });

    document.getElementById('end-call').addEventListener('click', () => {
        console.log("End call clicked.");
        safeSend({ type: 'call_end', call_id: callId });
        cleanupCallUI();
    });

    // ---- Chat message submit ----
    document.querySelector('#chat-form').onsubmit = function(e) {
        e.preventDefault();
        const messageInputDom = document.querySelector('#chat-message-input');
        const message = messageInputDom.value.trim();
        if (!message) return;
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({ type: 'chat_message', message: message, sender: currentUser }));
            messageInputDom.value = '';
        } else {
            // queue as well
            safeSend({ type: 'chat_message', message: message });
            messageInputDom.value = '';
        }
    };

    // ---- Delete message and conversation handlers (unchanged behaviour) ----
    document.querySelector('#chat-log').addEventListener('click', function(e) {
        if (e.target && e.target.classList.contains('delete-message-btn')) {
            const messageId = e.target.dataset.messageId;
            if (confirm('Are you sure you want to delete this message?')) {
                fetch(`/messages/delete_message/${messageId}/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message_id: messageId })
                }).then(r => r.json()).then(j => {
                    if (j.status !== 'ok') alert('Error deleting message: ' + (j.message || 'unknown'));
                }).catch(err => console.error(err));
            }
        }
    });

    document.querySelector('#delete-conversation-btn').addEventListener('click', function(e) {
        e.preventDefault();
        if (confirm('Are you sure you want to delete this conversation?')) {
            fetch(`/messages/delete_conversation/${conversationId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ conversation_id: conversationId })
            }).then(r => r.json()).then(j => {
                if (j.status !== 'ok') alert('Error deleting conversation: ' + (j.message || 'unknown'));
            }).catch(err => console.error(err));
        }
    });

    // ---- CSRF helper ----
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // ---- helpful keyboard focus ----
    document.querySelector('#chat-message-input').focus();
});
</script>
{% endblock %}
